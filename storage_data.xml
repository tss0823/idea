<application>
  <component name="AppStorage">
    <histories>
      <item value="If the map previously contained a mapping for the key , the old value is replaced ." />
      <item value="Associates the specified value with the specified key in this map" />
      <item value="Associates" />
      <item value="Retrieve object hash code and applies a supplemental hash function to the result hash , which defends against poor quality hash functions . This is critical because Hash Map uses power - of - two length hash tables , that otherwise encounter collisions for hash Codes that do not differ in lower bits . Note : Null keys always map to hash 0, thus index 0" />
      <item value="redo" />
      <item value="The number of times this Hash Map has been structurally modified Structural modifications are those that change the number of mappings in the Hash Map or otherwise modify its internal structure ( e . g ., rehash ). This field is used to make iterators on Collection - views of the Hash Map fail - fast" />
      <item value="stale" />
      <item value="Expunges" />
      <item value="Expunges stale entries from the table ." />
      <item value="invoker" />
      <item value="exporter" />
      <item value="export" />
      <item value="recover" />
      <item value="dying" />
      <item value="completed Abruptly" />
      <item value="Abruptly" />
      <item value="instructed" />
      <item value="opportunity" />
      <item value="fair" />
      <item value="representing" />
      <item value="boxed" />
      <item value="pairs" />
      <item value="Acquires the lock unless the current thread is {@ linkplain Thread # interrupt interrupted }." />
      <item value="Phantom" />
      <item value="An invocation of this method behaves in exactly the same way as the invocation" />
      <item value="A hint to the scheduler that the current thread is willing to yield its current use of a processor . The scheduler is free to ignore this hint" />
      <item value="so prevents false alarms that would add threads when it shouldn ' t" />
      <item value="If a task can be successfully queued , then we still need to double - check whether we should have added a thread ( because existing ones died since last checking ) or that the pool shut down since entry into this method . So we recheck state and if necessary roll back the enqueuing if stopped , or start a new thread if there are none" />
      <item value="If fewer than core Pool Size threads are running , try to start a new thread with the given command as its first task . The call to add Worker atomically checks run State and worker Count , and so prevents false alarms that would add threads when it shouldn ' t , by returning false ." />
      <item value="1. If fewer than core Pool Size threads are running , try to start a new thread with the given command as its first task . The call to add Worker atomically checks run State and worker Count , and so prevents false alarms that would add threads when it shouldn ' t , by returning false" />
      <item value="requested stack size for this thread" />
      <item value="multiplexed" />
      <item value="taking into account" />
      <item value="Fills the buffer with more data , taking into account" />
      <item value="hence pos &gt; count" />
      <item value="This method also assumes that all data has already been read in" />
      <item value="Assumes that it is being called by a synchronized method" />
      <item value="shuffling and other tricks for dealing with marks" />
      <item value="padded" />
      <item value="fabricated" />
      <item value="Swing Utilities" />
      <item value="platette" />
      <item value="platate" />
      <item value="Accessible Context Util Compat" />
      <item value="Compat" />
      <item value="relative" />
      <item value="translate" />
      <item value="打开翻译对话框" />
      <item value="Sticky" />
      <item value="Balloon" />
    </histories>
  </component>
</application>