<application>
  <component name="AppStorage">
    <histories>
      <item value="This method should only be called by a thread that is the owner of this object ' s monitor" />
      <item value="Yield is a heuristic attempt to improve relative progression between threads that would otherwise over - utilise a CPU" />
      <item value="heuristic" />
      <item value="particular" />
      <item value="Acquires in exclusive uninterruptible mode for thread already in queue . Used by condition wait methods as well as acquire ." />
      <item value="predecessor" />
      <item value="exclusive" />
      <item value="indicate" />
      <item value="fair" />
      <item value="Nonfair Sync" />
      <item value="mesh" />
      <item value="The bin count threshold for using a tree rather than list for a bin . Bins are converted to trees when adding an element to a bin with at least this many nodes . The value must be greater than 2 and should be at least 8 to mesh with assumptions in tree removal about conversion back to plain bins upon shrinkage ." />
      <item value="many short - lived asynchronous tasks" />
      <item value="reuse" />
      <item value="threshold" />
      <item value="Computes key . hash Code () and spreads ( XO Rs ) higher bits of hash to lower . Because the table uses power - of - two masking , sets of hashes that vary only in bits above the current mask will always collide . ( Among known examples are sets of Float keys holding consecutive whole numbers in small tables .) So we apply a transform that spreads the impact of higher bits downward . There is a tradeoff between speed , utility , and quality of bit - spreading . Because many common sets of hashes are already reasonably distributed ( so don ' t benefit from spreading ), and because we use trees to handle large sets of collisions in bins , we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage , as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds ." />
      <item value="If the map previously contained a mapping for the key , the old value is replaced ." />
      <item value="Associates the specified value with the specified key in this map" />
      <item value="Associates" />
      <item value="Retrieve object hash code and applies a supplemental hash function to the result hash , which defends against poor quality hash functions . This is critical because Hash Map uses power - of - two length hash tables , that otherwise encounter collisions for hash Codes that do not differ in lower bits . Note : Null keys always map to hash 0, thus index 0" />
      <item value="redo" />
      <item value="The number of times this Hash Map has been structurally modified Structural modifications are those that change the number of mappings in the Hash Map or otherwise modify its internal structure ( e . g ., rehash ). This field is used to make iterators on Collection - views of the Hash Map fail - fast" />
      <item value="stale" />
      <item value="Expunges" />
      <item value="Expunges stale entries from the table ." />
      <item value="invoker" />
      <item value="exporter" />
      <item value="export" />
      <item value="recover" />
      <item value="dying" />
      <item value="completed Abruptly" />
      <item value="Abruptly" />
      <item value="instructed" />
      <item value="opportunity" />
      <item value="representing" />
      <item value="boxed" />
      <item value="pairs" />
      <item value="Acquires the lock unless the current thread is {@ linkplain Thread # interrupt interrupted }." />
      <item value="Phantom" />
      <item value="An invocation of this method behaves in exactly the same way as the invocation" />
      <item value="A hint to the scheduler that the current thread is willing to yield its current use of a processor . The scheduler is free to ignore this hint" />
      <item value="so prevents false alarms that would add threads when it shouldn ' t" />
      <item value="If a task can be successfully queued , then we still need to double - check whether we should have added a thread ( because existing ones died since last checking ) or that the pool shut down since entry into this method . So we recheck state and if necessary roll back the enqueuing if stopped , or start a new thread if there are none" />
      <item value="If fewer than core Pool Size threads are running , try to start a new thread with the given command as its first task . The call to add Worker atomically checks run State and worker Count , and so prevents false alarms that would add threads when it shouldn ' t , by returning false ." />
      <item value="1. If fewer than core Pool Size threads are running , try to start a new thread with the given command as its first task . The call to add Worker atomically checks run State and worker Count , and so prevents false alarms that would add threads when it shouldn ' t , by returning false" />
      <item value="requested stack size for this thread" />
      <item value="multiplexed" />
      <item value="taking into account" />
      <item value="Fills the buffer with more data , taking into account" />
      <item value="hence pos &gt; count" />
    </histories>
  </component>
</application>