<application>
  <component name="AppStorage">
    <histories>
      <item value="differently" />
      <item value="Returns the context Class Loader for this Thread . The context Class Loader is provided by the creator of the thread for use by code running in this thread when loading classes and resources . If not {@ linkplain # set Context Class Loader set }, the default is the Class Loader context of the parent Thread . The context Class Loader of the primordial thread is typically set to the class loader used to load the application" />
      <item value="When the keepalive option is set for a TCP socket and no data has been exchanged across the socket in either direction for 2 hours ( NOTE : the actual value is implementation dependent ), TCP automatically sends a keepalive probe to the peer . This probe is a TCP segment to which the peer must respond . One of three responses is expected :" />
      <item value="Disable Nagle ' s algorithm for this connection . Written data to the network is not buffered pending acknowledgement of previously written data" />
      <item value="Heuristically scan some cells looking for stale entries . This is invoked when either a new element is added , or another stale one has been expunged . It performs a logarithmic number of scans , as a balance between no scanning ( fast but retains garbage ) and a number of scans proportional to number of elements , that would find all garbage but would cause some insertions to take O ( n ) time ." />
      <item value="The load factor for the hash table" />
      <item value="This method should only be called by a thread that is the owner of this object ' s monitor" />
      <item value="Yield is a heuristic attempt to improve relative progression between threads that would otherwise over - utilise a CPU" />
      <item value="heuristic" />
      <item value="particular" />
      <item value="Acquires in exclusive uninterruptible mode for thread already in queue . Used by condition wait methods as well as acquire ." />
      <item value="predecessor" />
      <item value="exclusive" />
      <item value="indicate" />
      <item value="fair" />
      <item value="Nonfair Sync" />
      <item value="mesh" />
      <item value="The bin count threshold for using a tree rather than list for a bin . Bins are converted to trees when adding an element to a bin with at least this many nodes . The value must be greater than 2 and should be at least 8 to mesh with assumptions in tree removal about conversion back to plain bins upon shrinkage ." />
      <item value="many short - lived asynchronous tasks" />
      <item value="reuse" />
      <item value="threshold" />
      <item value="Computes key . hash Code () and spreads ( XO Rs ) higher bits of hash to lower . Because the table uses power - of - two masking , sets of hashes that vary only in bits above the current mask will always collide . ( Among known examples are sets of Float keys holding consecutive whole numbers in small tables .) So we apply a transform that spreads the impact of higher bits downward . There is a tradeoff between speed , utility , and quality of bit - spreading . Because many common sets of hashes are already reasonably distributed ( so don ' t benefit from spreading ), and because we use trees to handle large sets of collisions in bins , we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage , as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds ." />
      <item value="If the map previously contained a mapping for the key , the old value is replaced ." />
      <item value="Associates the specified value with the specified key in this map" />
      <item value="Associates" />
      <item value="Retrieve object hash code and applies a supplemental hash function to the result hash , which defends against poor quality hash functions . This is critical because Hash Map uses power - of - two length hash tables , that otherwise encounter collisions for hash Codes that do not differ in lower bits . Note : Null keys always map to hash 0, thus index 0" />
      <item value="redo" />
      <item value="The number of times this Hash Map has been structurally modified Structural modifications are those that change the number of mappings in the Hash Map or otherwise modify its internal structure ( e . g ., rehash ). This field is used to make iterators on Collection - views of the Hash Map fail - fast" />
      <item value="stale" />
      <item value="Expunges" />
      <item value="Expunges stale entries from the table ." />
      <item value="invoker" />
      <item value="exporter" />
      <item value="export" />
      <item value="recover" />
      <item value="dying" />
      <item value="completed Abruptly" />
      <item value="Abruptly" />
      <item value="instructed" />
      <item value="opportunity" />
      <item value="representing" />
      <item value="boxed" />
      <item value="pairs" />
      <item value="Acquires the lock unless the current thread is {@ linkplain Thread # interrupt interrupted }." />
      <item value="Phantom" />
      <item value="An invocation of this method behaves in exactly the same way as the invocation" />
      <item value="A hint to the scheduler that the current thread is willing to yield its current use of a processor . The scheduler is free to ignore this hint" />
      <item value="so prevents false alarms that would add threads when it shouldn ' t" />
      <item value="If a task can be successfully queued , then we still need to double - check whether we should have added a thread ( because existing ones died since last checking ) or that the pool shut down since entry into this method . So we recheck state and if necessary roll back the enqueuing if stopped , or start a new thread if there are none" />
      <item value="If fewer than core Pool Size threads are running , try to start a new thread with the given command as its first task . The call to add Worker atomically checks run State and worker Count , and so prevents false alarms that would add threads when it shouldn ' t , by returning false ." />
    </histories>
  </component>
</application>