<application>
  <component name="AppStorage">
    <histories>
      <item value="recover" />
      <item value="dying" />
      <item value="completed Abruptly" />
      <item value="Abruptly" />
      <item value="instructed" />
      <item value="opportunity" />
      <item value="fair" />
      <item value="representing" />
      <item value="boxed" />
      <item value="pairs" />
      <item value="Acquires the lock unless the current thread is {@ linkplain Thread # interrupt interrupted }." />
      <item value="Phantom" />
      <item value="An invocation of this method behaves in exactly the same way as the invocation" />
      <item value="A hint to the scheduler that the current thread is willing to yield its current use of a processor . The scheduler is free to ignore this hint" />
      <item value="so prevents false alarms that would add threads when it shouldn ' t" />
      <item value="If a task can be successfully queued , then we still need to double - check whether we should have added a thread ( because existing ones died since last checking ) or that the pool shut down since entry into this method . So we recheck state and if necessary roll back the enqueuing if stopped , or start a new thread if there are none" />
      <item value="If fewer than core Pool Size threads are running , try to start a new thread with the given command as its first task . The call to add Worker atomically checks run State and worker Count , and so prevents false alarms that would add threads when it shouldn ' t , by returning false ." />
      <item value="1. If fewer than core Pool Size threads are running , try to start a new thread with the given command as its first task . The call to add Worker atomically checks run State and worker Count , and so prevents false alarms that would add threads when it shouldn ' t , by returning false" />
      <item value="requested stack size for this thread" />
      <item value="multiplexed" />
      <item value="taking into account" />
      <item value="Fills the buffer with more data , taking into account" />
      <item value="hence pos &gt; count" />
      <item value="This method also assumes that all data has already been read in" />
      <item value="Assumes that it is being called by a synchronized method" />
      <item value="shuffling and other tricks for dealing with marks" />
      <item value="padded" />
      <item value="fabricated" />
      <item value="Swing Utilities" />
      <item value="platette" />
      <item value="platate" />
      <item value="Accessible Context Util Compat" />
      <item value="Compat" />
      <item value="relative" />
      <item value="translate" />
      <item value="打开翻译对话框" />
      <item value="Sticky" />
      <item value="Balloon" />
      <item value="balloon" />
    </histories>
  </component>
</application>